#!/bin/bash

# jq Installation Script for Debian Linux
# Generated by Gearbox Script Generator - C/C++ Template
# Automated clone, dependency installation, configuration, build, and install
# Usage: ./install-jq.sh [OPTIONS]

set -e  # Exit on any error

# Find the script directory and load common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$SCRIPT_DIR")"

# Source common library for shared functions
if [[ -f "$REPO_DIR/lib/common.sh" ]]; then
    source "$REPO_DIR/lib/common.sh"
else
    echo "ERROR: common.sh not found in $REPO_DIR/lib/" >&2
    exit 1
fi

# Configuration
JQ_DIR="jq"
JQ_REPO="https://github.com/jqlang/jq.git"

# Default options
BUILD_TYPE="standard"
MODE="install"         # config, build, install
SKIP_DEPS=false
RUN_TESTS=false
FORCE_INSTALL=false
PARALLEL_JOBS=$(get_optimal_jobs)

# Show help
show_help() {
    cat << EOF
JSON processor (C)

Usage: $0 [OPTIONS]

Build Types:
  -o                   maximum build
  -m                   minimal build
  -s                   standard build

Modes:
  -c, --config-only     Configure only (prepare build)
  -b, --build-only      Configure and build (no install)
  -i, --install         Configure, build, and install (default)

Options:
  --skip-deps          Skip dependency installation
  --run-tests          Run test suite after building
  --force              Force reinstallation if already installed
  -j, --jobs N         Number of parallel jobs (default: auto-detect)
  -h, --help           Show this help message

Examples:
  $0                   # Default build and install
  $0 -m -c             # Minimal build, config only
  $0 -o --run-tests    # Full build with tests

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -o)
            BUILD_TYPE="maximum"
            shift
            ;;
        -m)
            BUILD_TYPE="minimal"
            shift
            ;;
        -s)
            BUILD_TYPE="standard"
            shift
            ;;
        -c|--config-only)
            MODE="config"
            shift
            ;;
        -b|--build-only)
            MODE="build"
            shift
            ;;
        -i|--install)
            MODE="install"
            shift
            ;;
        --skip-deps)
            SKIP_DEPS=true
            shift
            ;;
        --run-tests)
            RUN_TESTS=true
            shift
            ;;
        --force)
            FORCE_INSTALL=true
            shift
            ;;
        -j|--jobs)
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Get configure options based on build type
get_configure_options() {
    local options="--prefix=/usr/local/bin"
    
    case $BUILD_TYPE in
        debug|minimal)
            options="$options --enable-debug --disable-optimization"
            ;;
        release|standard)
            options="$options --disable-debug --enable-optimization"
            ;;
        optimized|maximum)
            options="$options --disable-debug --enable-optimization --enable-all-features"
            ;;
        static)
            options="$options --disable-shared --enable-static"
            ;;
    esac
    


    
    echo "$options"
}

# Get make options based on build type
get_make_options() {
    local options="-j$PARALLEL_JOBS"
    
    case $BUILD_TYPE in
        debug|minimal)
            options="$options CFLAGS='-g -O0'"
            ;;
        release|standard)
            options="$options CFLAGS='-O2 -DNDEBUG'"
            ;;
        optimized|maximum)
            options="$options CFLAGS='-O3 -march=native -DNDEBUG'"
            ;;
        static)
            options="$options LDFLAGS='-static'"
            ;;
    esac
    
    echo "$options"
}

# Install dependencies
install_dependencies() {
    if [[ "$SKIP_DEPS" == true ]]; then
        log "Skipping dependency installation as requested"
        return 0
    fi

    # Update package list
    log "Updating package list..."
    sudo apt update || error "Failed to update package list"

    # Install basic build tools
    log "Installing build tools..."
    sudo apt install -y \
        build-essential \
        git \
        curl \
        wget \
        pkg-config \
        autoconf \
        automake \
        libtool \
        make \
        cmake \
        nasm \
        yasm \
        || error "Failed to install build tools"






    success "Dependencies installed successfully"
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   error "This script should not be run as root for security reasons"
fi

log "Starting jq $MODE process for Debian Linux"
log "Build type: $BUILD_TYPE"
log "Mode: $MODE"
log "Parallel jobs: $PARALLEL_JOBS"

# Handle jq source code
if [[ -d "$JQ_DIR" ]]; then
    log "Found existing jq directory: $JQ_DIR"
    
    # Check if it's a git repository
    if [[ -d "$JQ_DIR/.git" ]]; then
        log "Existing directory is a git repository"
        
        # Check if it's the correct repository
        cd "$JQ_DIR"
        CURRENT_ORIGIN=$(git remote get-url origin 2>/dev/null || echo "")
        
        if [[ "$CURRENT_ORIGIN" == "$JQ_REPO" ]]; then
            log "Repository origin matches expected jq repository"
            
            log "Pulling latest changes..."
            git pull origin main || git pull origin master || warning "Failed to pull latest changes"
            success "Repository updated successfully"
        else
            warning "Existing git repository has different origin: $CURRENT_ORIGIN"
            cd ..
            rm -rf "$JQ_DIR"
            log "Cloning jq repository..."
            git clone "$JQ_REPO" "$JQ_DIR" || error "Failed to clone jq repository"
            cd "$JQ_DIR"
            success "jq repository cloned successfully"
        fi
        cd ..
    else
        warning "Directory exists but is not a git repository"
        rm -rf "$JQ_DIR"
        log "Cloning jq repository..."
        git clone "$JQ_REPO" "$JQ_DIR" || error "Failed to clone jq repository"
        success "jq repository cloned successfully"
    fi
else
    log "Cloning jq repository..."
    git clone "$JQ_REPO" "$JQ_DIR" || error "Failed to clone jq repository"
    success "jq repository cloned successfully"
fi

# Change to jq directory
cd "$JQ_DIR"

# Verify we're in the correct directory
if [[ ! -f "configure" && ! -f "configure.ac" && ! -f "Makefile" && ! -f "CMakeLists.txt" ]]; then
    error "Invalid jq source directory - missing build configuration files"
fi

# Install dependencies
install_dependencies

# Clean previous build
log "Cleaning previous build files..."
make clean &>/dev/null || true
make distclean &>/dev/null || true

# Get build configuration
CONFIGURE_OPTIONS=$(get_configure_options)
MAKE_OPTIONS=$(get_make_options)

log "Configuring jq with $BUILD_TYPE settings..."
log "Configure options: $CONFIGURE_OPTIONS"
log "Make options: $MAKE_OPTIONS"

# Run autogen/bootstrap if needed
if [[ -f "autogen.sh" ]]; then
    log "Running autogen.sh..."
    ./autogen.sh || error "Failed to run autogen.sh"
elif [[ -f "bootstrap" ]]; then
    log "Running bootstrap..."
    ./bootstrap || error "Failed to run bootstrap"
elif [[ -f "configure.ac" && ! -f "configure" ]]; then
    log "Running autoreconf..."
    autoreconf -fiv || error "Failed to run autoreconf"
fi

success "Configuration completed successfully"

# Exit if config-only mode
if [[ "$MODE" == "config" ]]; then
    success "Configuration completed. Run with --build-only or --install to continue."
    if [[ -f "configure" ]]; then
        success "Configure command would be: ./configure $CONFIGURE_OPTIONS"
    elif [[ -f "CMakeLists.txt" ]]; then
        success "Build command would be: cmake . && make $MAKE_OPTIONS"
    else
        success "Build command would be: make $MAKE_OPTIONS"
    fi
    exit 0
fi

# Configure the build
log "Configuring jq build system..."

if [[ -f "configure" ]]; then
    configure_with_options "./configure" "$CONFIGURE_OPTIONS"
elif [[ -f "CMakeLists.txt" ]]; then
    log "Using CMake build system..."
    mkdir -p build
    cd build
    cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/bin || error "Failed to configure with CMake"
    cd ..
else
    log "Using direct Makefile build"
fi

# Build jq
log "Building jq (this may take a while)..."

if [[ -d "build" ]]; then
    cd build
    build_with_options make "$MAKE_OPTIONS"
    cd ..
else
    build_with_options make "$MAKE_OPTIONS"
fi

success "Build completed successfully"

# Run tests if requested
if [[ "$RUN_TESTS" == true ]]; then
    log "Running test suite..."
    if [[ -d "build" ]]; then
        cd build
        make test || warning "Some tests failed, but continuing"
        cd ..
    else
        make test || make check || warning "Some tests failed, but continuing"
    fi
    success "Test suite completed"
fi

# Exit if build-only mode
if [[ "$MODE" == "build" ]]; then
    success "Build completed. Run with --install to install the binaries."
    exit 0
fi

# Install jq
log "Installing jq..."

# Get version for cache operations
version="unknown"
if command -v jq &> /dev/null; then
    version=$(jq --version 2>/dev/null | head -1 | cut -d' ' -f2 2>/dev/null || echo "unknown")
fi

# Check if we can use cached installation
if is_cached "jq" "$BUILD_TYPE" "$version"; then
    log "Found cached jq build, using cached version..."
    if get_cached_binary "jq" "$BUILD_TYPE" "$version" "jq"; then
        success "jq installed from cache successfully"
    else
        warning "Failed to use cached binary, proceeding with fresh installation"
        if [[ -d "build" ]]; then
            cd build
            sudo make install || error "Failed to install jq"
            cd ..
        else
            sudo make install || error "Failed to install jq"
        fi
        
        # Cache the new installation - get fresh version after installation
        version=$(jq --version 2>/dev/null | head -1 | cut -d' ' -f2 2>/dev/null || echo "unknown")
        cache_build "jq" "$BUILD_TYPE" "$version" "/usr/local/bin/jq"
    fi
else
    if [[ -d "build" ]]; then
        cd build
        sudo make install || error "Failed to install jq"
        cd ..
    else
        sudo make install || error "Failed to install jq"
    fi
    
    # Cache the new installation - get fresh version after installation
    version=$(jq --version 2>/dev/null | head -1 | cut -d' ' -f2 2>/dev/null || echo "unknown")
    cache_build "jq" "$BUILD_TYPE" "$version" "/usr/local/bin/jq"
fi

# Update library cache
sudo ldconfig || warning "Failed to update library cache"

# Verify installation
log "Verifying installation..."
# Update PATH to include install location
export PATH="/usr/local/bin:$PATH"
# Clear bash command hash table
hash -r

if command -v jq &> /dev/null; then
    success "jq installation verified!"
    echo
    log "jq version information:"
    jq --version || echo "Version command not available"
    echo
    log "Build type: $BUILD_TYPE"
    case $BUILD_TYPE in
        debug|minimal)
            log "Features: Debug/minimal build for development"
            ;;
        release|standard)
            log "Features: Optimized release build with standard features"
            ;;
        optimized|maximum)
            log "Features: Fully optimized build with all features enabled"
            ;;
        static)
            log "Features: Self-contained static binary"
            ;;
    esac
    echo
    success "jq installation completed successfully!"
    log "You can now use the 'jq' command"
    echo



    echo
    log "Installation paths:"
    log "  jq: $(which jq)"
    echo
    log "Script completed in directory: $(pwd)"
else
    error "jq installation verification failed - command not found in PATH"
fi