#!/bin/bash

# Yazi Installation Script for Debian Linux
# Automated dependency detection, installation, build, and install
# Usage: ./install-yazi.sh [OPTIONS]

set -e  # Exit on any error

# Find the script directory and load common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$SCRIPT_DIR")"

# Source common library for shared functions
if [[ -f "$REPO_DIR/lib/common.sh" ]]; then
    source "$REPO_DIR/lib/common.sh"
else
    echo "ERROR: common.sh not found in $REPO_DIR/lib/" >&2
    exit 1
fi


# Configuration
YAZI_DIR="yazi"
YAZI_REPO="https://github.com/sxyazi/yazi.git"
RUST_MIN_VERSION="1.70.0"

# Default options
BUILD_TYPE="release"   # debug, release
MODE="install"         # config, build, install
SKIP_DEPS=false
FORCE_INSTALL=false
INSTALL_MISSING=true

# Show help
show_help() {
    cat << EOF
Yazi Installation Script for Debian Linux

Usage: $0 [OPTIONS]

Build Types:
  -d, --debug           Debug build (unoptimized, for development)
  -r, --release         Release build (default, optimized)

Modes:
  -c, --config-only     Configure only (prepare build and check dependencies)
  -b, --build-only      Configure and build (no install)
  -i, --install         Configure, build, and install (default)

Options:
  --skip-deps          Skip dependency installation and checking
  --no-install-missing Do not install missing dependencies via apt
  --force              Force reinstallation if already installed
  -h, --help           Show this help message

Examples:
  $0                   # Default: release build with dependency checking
  $0 -d -c             # Debug build, config and dependency check only
  $0 --no-install-missing  # Don't install missing deps via apt
  $0 --skip-deps       # Skip all dependency management

Note: This script intelligently detects existing source-built tools
and only falls back to package manager for missing dependencies.

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--debug)
            BUILD_TYPE="debug"
            shift
            ;;
        -r|--release)
            BUILD_TYPE="release"
            shift
            ;;
        -c|--config-only)
            MODE="config"
            shift
            ;;
        -b|--build-only)
            MODE="build"
            shift
            ;;
        -i|--install)
            MODE="install"
            shift
            ;;
        --skip-deps)
            SKIP_DEPS=true
            shift
            ;;
        --no-install-missing)
            INSTALL_MISSING=false
            shift
            ;;
        --force)
            FORCE_INSTALL=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Note: Logging functions now provided by lib/common.sh

# Note: Logging functions now provided by lib/common.sh

# Note: Logging functions now provided by lib/common.sh

# Note: Logging functions now provided by lib/common.sh

ask_user() {
    while true; do
        read -p "$1 (y/n): " yn
        case $yn in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

# Version comparison function
version_compare() {
    if [[ $1 == $2 ]]; then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]]; then
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 0
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 1
        fi
    done
    return 0
}

# Check if a tool is likely from our source builds vs package manager
is_source_built() {
    local tool="$1"
    local tool_path=$(which "$tool" 2>/dev/null || echo "")
    
    if [[ -z "$tool_path" ]]; then
        return 1  # Not found
    fi
    
    # Check if it's in common source-build locations
    case "$tool_path" in
        /usr/local/bin/*|~/.cargo/bin/*|$HOME/.cargo/bin/*)
            return 0  # Likely source-built
            ;;
        *)
            return 1  # Likely package manager
            ;;
    esac
}

# Smart dependency checker
check_dependency() {
    local tool="$1"
    local package="$2"
    local description="$3"
    local required="$4"  # true/false
    
    if command -v "$tool" &> /dev/null; then
        local version=""
        case "$tool" in
            ffmpeg) version=$(ffmpeg -version 2>/dev/null | head -n1 | cut -d' ' -f3 || echo "unknown") ;;
            7zz|7z) version=$(7zz 2>/dev/null | head -n3 | tail -n1 | cut -d' ' -f4 || echo "unknown") ;;
            jq) version=$(jq --version 2>/dev/null || echo "unknown") ;;
            fd|fdfind) version=$(fd --version 2>/dev/null || fdfind --version 2>/dev/null || echo "unknown") ;;
            rg) version=$(rg --version 2>/dev/null | head -n1 | cut -d' ' -f2 || echo "unknown") ;;
            fzf) version=$(fzf --version 2>/dev/null | cut -d' ' -f1 || echo "unknown") ;;
            zoxide) version=$(zoxide --version 2>/dev/null || echo "unknown") ;;
            magick) version=$(magick -version 2>/dev/null | head -n1 | awk '{print $3}' || echo "unknown") ;;
            *) version="present" ;;
        esac
        
        if is_source_built "$tool"; then
            success "$description found: $tool ($version) [source-built]"
            return 0
        else
            warning "$description found: $tool ($version) [package manager - consider upgrading with our scripts]"
            return 0
        fi
    else
        if [[ "$required" == "true" ]]; then
            error "$description not found: $tool"
        else
            warning "$description not found: $tool (optional)"
            if [[ "$INSTALL_MISSING" == "true" ]] && [[ -n "$package" ]]; then
                log "Will install $package via apt"
                return 2  # Needs installation
            fi
            return 1
        fi
    fi
}

# Install missing dependencies
install_missing_dependencies() {
    local packages_to_install=()
    
    log "Checking dependencies..."
    
    # Required dependency (system utility - package manager is fine)
    if command -v file &> /dev/null; then
        success "file command found: file (system utility) [OK]"
    else
        packages_to_install+=("file")
    fi
    
    # Optional but recommended dependencies
    local deps_to_check=(
        "ffmpeg:ffmpeg:FFmpeg multimedia framework:false"
        "7zz:p7zip-full:7-Zip archiver:false"
        "jq:jq:JSON processor:false"
        "fd:fd-find:Fast file finder:false"
        "rg:ripgrep:Fast text search:false" 
        "fzf:fzf:Fuzzy finder:false"
        "zoxide:zoxide:Smart directory jumper:false"
        "magick:imagemagick:Image manipulation:false"
    )
    
    local missing_tools=()
    for dep in "${deps_to_check[@]}"; do
        IFS=':' read -r tool package description required <<< "$dep"
        local result
        check_dependency "$tool" "$package" "$description" "$required"
        result=$?
        if [[ $result -eq 2 ]]; then
            packages_to_install+=("$package")
            missing_tools+=("$tool")
        elif [[ $result -eq 1 ]] && [[ "$required" == "false" ]]; then
            missing_tools+=("$tool")
        fi
    done
    
    # Check poppler-utils separately (system utility - package manager is fine)
    if command -v pdftoppm &> /dev/null; then
        success "PDF utilities found: pdftoppm (poppler-utils) [OK]"
    else
        log "PDF utilities not found, will install poppler-utils via apt"
        packages_to_install+=("poppler-utils")
    fi
    
    # Show suggestions for missing tools
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        echo
        warning "Some optional dependencies are missing or could be upgraded:"
        for tool in "${missing_tools[@]}"; do
            case "$tool" in
                ffmpeg) log "  Consider running: ./install-ffmpeg.sh" ;;
                7zz) log "  Consider running: ./install-7zip.sh" ;;
                jq) log "  Consider running: ./install-jq.sh" ;;
                fd) log "  Consider running: ./install-fd.sh" ;;
                rg) log "  Consider running: ./install-ripgrep.sh" ;;
                fzf) log "  Consider running: ./install-fzf.sh" ;;
                zoxide) log "  Consider running: ./install-zoxide.sh" ;;
                magick) log "  Consider running: ./install-imagemagick.sh" ;;
                *) log "  Missing: $tool" ;;
            esac
        done
        echo
    fi
    
    # Install packages if needed
    if [[ ${#packages_to_install[@]} -gt 0 ]] && [[ "$INSTALL_MISSING" == "true" ]]; then
        log "Installing missing packages via apt: ${packages_to_install[*]}"
        sudo apt update || error "Failed to update package list"
        sudo apt install -y "${packages_to_install[@]}" || error "Failed to install packages"
        success "Missing packages installed"
    elif [[ ${#packages_to_install[@]} -gt 0 ]]; then
        warning "Missing packages (use --install-missing to auto-install): ${packages_to_install[*]}"
    fi
}

# Check and install Rust
install_rust() {
    if command -v rustc &> /dev/null; then
        local current_version=$(rustc --version | cut -d' ' -f2)
        log "Found Rust version: $current_version"
        
        if version_compare $current_version $RUST_MIN_VERSION; then
            log "Rust version is sufficient (>= $RUST_MIN_VERSION)"
            return 0
        else
            warning "Rust version $current_version is below minimum required $RUST_MIN_VERSION"
            if ask_user "Do you want to update Rust?"; then
                log "Updating Rust..."
                rustup update || error "Failed to update Rust"
                success "Rust updated successfully"
            else
                error "Cannot proceed with insufficient Rust version"
            fi
        fi
    else
        log "Rust not found, installing..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y || error "Failed to install Rust"
        source ~/.cargo/env || error "Failed to source Rust environment"
        success "Rust installed successfully"
    fi
}

# Install basic dependencies
install_basic_dependencies() {
    if [[ "$SKIP_DEPS" == true ]]; then
        log "Skipping dependency installation as requested"
        return 0
    fi

    # Update package list
    log "Updating package list..."
    sudo apt update || error "Failed to update package list"

    # Install basic build tools
    log "Installing build tools..."
    sudo apt install -y \
        build-essential \
        git \
        curl \
        || error "Failed to install build tools"

    # Install Rust
    install_rust

    # Check yazi-specific dependencies
    install_missing_dependencies

    success "Dependencies handled successfully"
}

# Get cargo build options
get_cargo_build_options() {
    case $BUILD_TYPE in
        debug)
            echo ""
            ;;
        release)
            echo "--release --locked"
            ;;
    esac
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   error "This script should not be run as root for security reasons"
fi

log "Starting yazi $MODE process for Debian Linux"
log "Build type: $BUILD_TYPE"
log "Mode: $MODE"

# Handle yazi source code
if [[ -d "$YAZI_DIR" ]]; then
    log "Found existing yazi directory: $YAZI_DIR"
    
    # Check if it's a git repository
    if [[ -d "$YAZI_DIR/.git" ]]; then
        log "Existing directory is a git repository"
        
        # Check if it's the correct repository
        cd "$YAZI_DIR"
        CURRENT_ORIGIN=$(git remote get-url origin 2>/dev/null || echo "")
        
        if [[ "$CURRENT_ORIGIN" == "$YAZI_REPO" ]]; then
            log "Repository origin matches expected yazi repository"
            
            if ask_user "Do you want to pull the latest changes from the yazi repository?"; then
                log "Pulling latest changes..."
                git pull origin main || error "Failed to pull latest changes"
                success "Repository updated successfully"
            else
                log "Using existing code without updates"
            fi
        else
            warning "Existing git repository has different origin: $CURRENT_ORIGIN"
            if ask_user "Do you want to remove this directory and clone fresh yazi repository?"; then
                cd ..
                rm -rf "$YAZI_DIR"
                log "Cloning yazi repository..."
                git clone "$YAZI_REPO" "$YAZI_DIR" || error "Failed to clone yazi repository"
                cd "$YAZI_DIR"
                success "yazi repository cloned successfully"
            else
                log "Continuing with existing repository"
            fi
        fi
        cd ..
    else
        warning "Directory exists but is not a git repository"
        if ask_user "Do you want to remove this directory and clone fresh yazi repository?"; then
            rm -rf "$YAZI_DIR"
            log "Cloning yazi repository..."
            git clone "$YAZI_REPO" "$YAZI_DIR" || error "Failed to clone yazi repository"
            success "yazi repository cloned successfully"
        else
            error "Cannot proceed without a proper yazi source directory"
        fi
    fi
else
    log "Cloning yazi repository..."
    git clone "$YAZI_REPO" "$YAZI_DIR" || error "Failed to clone yazi repository"
    success "yazi repository cloned successfully"
fi

# Change to yazi directory
cd "$YAZI_DIR"

# Verify we're in the correct directory
if [[ ! -f "Cargo.toml" ]]; then
    error "Invalid yazi source directory - missing Cargo.toml"
fi

# Install dependencies
install_basic_dependencies

# Ensure cargo is in PATH
if ! command -v cargo &> /dev/null; then
    source ~/.cargo/env || error "Failed to source Rust environment"
fi

# Clean previous build
log "Cleaning previous build files..."
cargo clean || warning "Failed to clean previous build, continuing..."

# Get build configuration
CARGO_BUILD_OPTIONS=$(get_cargo_build_options)

log "Configuring yazi with $BUILD_TYPE settings..."
log "Cargo build options: $CARGO_BUILD_OPTIONS"

success "Configuration completed successfully"

# Exit if config-only mode
if [[ "$MODE" == "config" ]]; then
    success "Configuration completed. Run with --build-only or --install to continue."
    if [[ -n "$CARGO_BUILD_OPTIONS" ]]; then
        success "Build command would be: cargo build $CARGO_BUILD_OPTIONS"
    else
        success "Build command would be: cargo build"
    fi
    exit 0
fi

# Build yazi
log "Building yazi (this may take a while)..."

if [[ -n "$CARGO_BUILD_OPTIONS" ]]; then
    build_with_options cargo "$CARGO_BUILD_OPTIONS"
else
    execute_command_safely cargo build
fi

# Verify build output
BUILD_DIR="target"
if [[ "$BUILD_TYPE" == "debug" ]]; then
    BUILD_DIR="$BUILD_DIR/debug"
else
    BUILD_DIR="$BUILD_DIR/release"
fi

if [[ ! -f "$BUILD_DIR/yazi" ]] || [[ ! -f "$BUILD_DIR/ya" ]]; then
    error "Build completed but yazi/ya executables not found in $BUILD_DIR"
fi

success "Build completed successfully"

# Exit if build-only mode
if [[ "$MODE" == "build" ]]; then
    success "Build completed. Run with --install to install."
    log "Build output:"
    log "  yazi: $(pwd)/$BUILD_DIR/yazi"
    log "  ya: $(pwd)/$BUILD_DIR/ya"
    exit 0
fi

# Install yazi
log "Installing yazi..."

# Install the binaries to system location
sudo cp "$BUILD_DIR/yazi" /usr/local/bin/ || error "Installation of yazi failed"
sudo cp "$BUILD_DIR/ya" /usr/local/bin/ || error "Installation of ya failed"
sudo chmod +x /usr/local/bin/yazi /usr/local/bin/ya || error "Failed to set executable permissions"

# Add cargo bin to PATH if not already there
if [[ ":$PATH:" != *":$HOME/.cargo/bin:"* ]]; then
    log "Adding ~/.cargo/bin to PATH..."
    echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
    export PATH="$HOME/.cargo/bin:$PATH"
    warning "You may need to restart your shell or run 'source ~/.bashrc' for PATH changes to take effect"
fi

# Verify installation
log "Verifying installation..."
# Force PATH update for verification
export PATH="/usr/local/bin:$HOME/.cargo/bin:$PATH"
# Clear bash command hash table to ensure new binaries are used
hash -r
if command -v yazi &> /dev/null && command -v ya &> /dev/null; then
    success "yazi installation verified!"
    echo
    log "yazi version information:"
    yazi --version
    ya --version
    echo
    log "Build type: $BUILD_TYPE"
    case $BUILD_TYPE in
        debug)
            log "Features: Debug build with symbols for development"
            ;;
        release)
            log "Features: Optimized release build for daily use"
            ;;
    esac
    echo
    success "yazi installation completed successfully!"
    log "You can now use yazi as a blazingly fast terminal file manager"
    echo
    log "Usage examples:"
    log "  yazi                         # Launch file manager"
    log "  yazi /path/to/directory      # Open specific directory"
    log "  ya --help                    # Command-line interface help"
    echo
    log "Key features:"
    log "  - Full async I/O for smooth performance"
    log "  - Powerful async task scheduling and management"
    log "  - Built-in code highlighting and image preview"
    log "  - Vim-like modal interaction"
    echo
    log "Installation paths:"
    log "  yazi: $(which yazi)"
    log "  ya: $(which ya)"
    echo
    log "To use immediately in this terminal, run: hash -r && source ~/.bashrc"
    log "Script completed in directory: $(pwd)"
else
    error "yazi installation verification failed - try restarting your shell or run 'source ~/.bashrc'"
fi
