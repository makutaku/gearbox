#!/bin/bash

# fzf Installation Script for Debian Linux
# Generated by Gearbox Script Generator - Go Template
# Automated clone, dependency installation, configuration, build, and install
# Usage: ./install-fzf.sh [OPTIONS]

set -e  # Exit on any error

# Find the script directory and load common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$(dirname "$(dirname "$(dirname "$SCRIPT_DIR")")")")"

# Source common library for shared functions
if [[ -f "$REPO_DIR/scripts/lib/common.sh" ]]; then
    source "$REPO_DIR/scripts/lib/common.sh"
else
    echo "ERROR: common.sh not found in $REPO_DIR/scripts/lib/" >&2
    exit 1
fi

# Configuration
FZF_DIR="fzf"
FZF_REPO="https://github.com/junegunn/fzf.git"
GO_MIN_VERSION="1.23.4"

# Default options
BUILD_TYPE="standard"
MODE="install"         # config, build, install
SKIP_DEPS=false
RUN_TESTS=false
FORCE_INSTALL=false
ENABLE_SHELL=true

# Show help
show_help() {
    cat << EOF
Fuzzy finder (Go)

Usage: $0 [OPTIONS]

Build Types:
  -p                   maximum build
  -s                   minimal build
  -s                   standard build

Modes:
  -c, --config-only     Configure only (prepare build)
  -b, --build-only      Configure and build (no install)
  -i, --install         Configure, build, and install (default)

Options:
  --skip-deps          Skip dependency installation
  --run-tests          Run test suite after building
  --force              Force reinstallation if already installed
  --no-shell           Skip shell integration setup
  -h, --help           Show this help message

Examples:
  $0                   # Default build and install
  $0 -s -c             # Minimal build, config only
  $0 -p --run-tests    # Full build with tests

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p)
            BUILD_TYPE="maximum"
            shift
            ;;
        -s)
            BUILD_TYPE="minimal"
            shift
            ;;
        -s)
            BUILD_TYPE="standard"
            shift
            ;;
        -c|--config-only)
            MODE="config"
            shift
            ;;
        -b|--build-only)
            MODE="build"
            shift
            ;;
        -i|--install)
            MODE="install"
            shift
            ;;
        --skip-deps)
            SKIP_DEPS=true
            shift
            ;;
        --run-tests)
            RUN_TESTS=true
            shift
            ;;
        --force)
            FORCE_INSTALL=true
            shift
            ;;
        --no-shell)
            ENABLE_SHELL=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Version comparison function
version_compare() {
    if [[ $1 == $2 ]]; then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]]; then
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 0
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 1
        fi
    done
    return 0
}

# Check and install Go
install_go() {
    if command -v go &> /dev/null; then
        local current_version=$(go version | cut -d' ' -f3 | sed 's/go//')
        log "Found Go version: $current_version"
        
        if version_compare $current_version $GO_MIN_VERSION; then
            log "Go version is sufficient (>= $GO_MIN_VERSION)"
            return 0
        else
            warning "Go version $current_version is below minimum required $GO_MIN_VERSION"
        fi
    fi
    
    log "Installing Go $GO_MIN_VERSION..."
    
    # Download and install Go
    local go_archive="go$GO_MIN_VERSION.linux-amd64.tar.gz"
    local download_url="https://golang.org/dl/$go_archive"
    
    # Remove old Go installation
    sudo rm -rf /usr/local/go
    
    # Download Go
    wget -O "$go_archive" "$download_url" || error "Failed to download Go"
    
    # Extract and install
    sudo tar -C /usr/local -xzf "$go_archive" || error "Failed to extract Go"
    
    # Clean up
    rm -f "$go_archive"
    
    # Add Go to PATH
    if [[ ":$PATH:" != *":/usr/local/go/bin:"* ]]; then
        echo 'export PATH="/usr/local/go/bin:$PATH"' >> ~/.bashrc
        export PATH="/usr/local/go/bin:$PATH"
    fi
    
    success "Go installed successfully"
}

# Get go build options based on build type
get_go_build_options() {
    local options=""
    
    case $BUILD_TYPE in
        debug|minimal)
            options="-ldflags='-w'"  # Strip debug info for smaller binary
            ;;
        release|standard)
            options="-ldflags='-s -w'"  # Strip symbol table and debug info
            ;;
        optimized|maximum)
            options="-ldflags='-s -w' -trimpath"  # Full optimization
            ;;
        static)
            options="-ldflags='-s -w -extldflags=-static' -tags netgo"
            ;;
    esac
    
    echo "$options"
}

# Get go install options
get_go_install_options() {
    local install_opts=""
    
    # Go install always uses go.mod for versioning
    if [[ "$FORCE_INSTALL" == true ]]; then
        install_opts="-a"  # Force rebuild of packages
    fi
    
    echo "$install_opts"
}

# Get environment variables for build
get_build_env() {
    case $BUILD_TYPE in
        static)
            echo "CGO_ENABLED=0 GOOS=linux GOARCH=amd64"
            ;;
        optimized|maximum)
            echo "CGO_ENABLED=1"
            ;;
        *)
            echo ""
            ;;
    esac
}

# Install dependencies
install_dependencies() {
    if [[ "$SKIP_DEPS" == true ]]; then
        log "Skipping dependency installation as requested"
        return 0
    fi

    # Update package list
    log "Updating package list..."
    sudo apt update || error "Failed to update package list"

    # Install basic build tools
    log "Installing build tools..."
    sudo apt install -y \
        build-essential \
        git \
        curl \
        wget \
        || error "Failed to install build tools"


    # Install Go
    install_go

    success "Dependencies installed successfully"
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   error "This script should not be run as root for security reasons"
fi

log "Starting fzf $MODE process for Debian Linux"
log "Build type: $BUILD_TYPE"
log "Mode: $MODE"

# Handle fzf source code
if [[ -d "$FZF_DIR" ]]; then
    log "Found existing fzf directory: $FZF_DIR"
    
    # Check if it's a git repository
    if [[ -d "$FZF_DIR/.git" ]]; then
        log "Existing directory is a git repository"
        
        # Check if it's the correct repository
        cd "$FZF_DIR"
        CURRENT_ORIGIN=$(git remote get-url origin 2>/dev/null || echo "")
        
        if [[ "$CURRENT_ORIGIN" == "$FZF_REPO" ]]; then
            log "Repository origin matches expected fzf repository"
            
            log "Pulling latest changes..."
            git pull origin main || git pull origin master || warning "Failed to pull latest changes"
            success "Repository updated successfully"
        else
            warning "Existing git repository has different origin: $CURRENT_ORIGIN"
            cd ..
            rm -rf "$FZF_DIR"
            log "Cloning fzf repository..."
            git clone "$FZF_REPO" "$FZF_DIR" || error "Failed to clone fzf repository"
            cd "$FZF_DIR"
            success "fzf repository cloned successfully"
        fi
        cd ..
    else
        warning "Directory exists but is not a git repository"
        rm -rf "$FZF_DIR"
        log "Cloning fzf repository..."
        git clone "$FZF_REPO" "$FZF_DIR" || error "Failed to clone fzf repository"
        success "fzf repository cloned successfully"
    fi
else
    log "Cloning fzf repository..."
    git clone "$FZF_REPO" "$FZF_DIR" || error "Failed to clone fzf repository"
    success "fzf repository cloned successfully"
fi

# Change to fzf directory
cd "$FZF_DIR"

# Verify we're in the correct directory
if [[ ! -f "go.mod" && ! -f "main.go" ]]; then
    error "Invalid fzf source directory - missing go.mod or main.go"
fi

# Install dependencies
install_dependencies

# Ensure go is in PATH
if ! command -v go &> /dev/null; then
    export PATH="/usr/local/go/bin:$PATH"
    if ! command -v go &> /dev/null; then
        error "Go installation not found in PATH"
    fi
fi

# Clean previous build
log "Cleaning previous build files..."
go clean -cache -modcache -testcache || warning "Failed to clean Go cache, continuing..."

# Get build configuration
GO_BUILD_OPTIONS=$(get_go_build_options)
GO_INSTALL_OPTIONS=$(get_go_install_options)
BUILD_ENV=$(get_build_env)

log "Configuring fzf with $BUILD_TYPE settings..."
log "Go build options: $GO_BUILD_OPTIONS"
log "Go install options: $GO_INSTALL_OPTIONS"
if [[ -n "$BUILD_ENV" ]]; then
    log "Build environment: $BUILD_ENV"
fi

success "Configuration completed successfully"

# Exit if config-only mode
if [[ "$MODE" == "config" ]]; then
    success "Configuration completed. Run with --build-only or --install to continue."
    if [[ -n "$BUILD_ENV" ]]; then
        success "Build command would be: $BUILD_ENV go build $GO_BUILD_OPTIONS"
    else
        success "Build command would be: go build $GO_BUILD_OPTIONS"
    fi
    exit 0
fi

# Build fzf
log "Building fzf (this may take a while)..."

if [[ -n "$BUILD_ENV" ]]; then
    if [[ -n "$GO_BUILD_OPTIONS" ]]; then
        env $BUILD_ENV build_with_options go "build $GO_BUILD_OPTIONS"
    else
        env $BUILD_ENV execute_command_safely go build
    fi
else
    if [[ -n "$GO_BUILD_OPTIONS" ]]; then
        build_with_options go "build $GO_BUILD_OPTIONS"
    else
        execute_command_safely go build
    fi
fi

# Verify build output
if [[ ! -f "fzf" && ! -f "./fzf" ]]; then
    error "Build completed but fzf executable not found"
fi

success "Build completed successfully"

# Run tests if requested
if [[ "$RUN_TESTS" == true ]]; then
    log "Running test suite..."
    go test -v ./... || warning "Some tests failed, but continuing"
    success "Test suite completed"
fi

# Exit if build-only mode
if [[ "$MODE" == "build" ]]; then
    success "Build completed. Run with --install to install the binary."
    log "Build output: $(pwd)/fzf"
    exit 0
fi

# Install fzf
log "Installing fzf..."

# Check if we can use cached binary
if is_cached "fzf" "$BUILD_TYPE"; then
    log "Found cached fzf build, using cached version..."
    if get_cached_binary "fzf" "$BUILD_TYPE" "/usr/local/bin/fzf"; then
        success "fzf installed from cache successfully"
    else
        warning "Failed to use cached binary, proceeding with fresh installation"
        # Install using go install or copy binary
        if [[ -f "go.mod" ]]; then
            if [[ -n "$GO_INSTALL_OPTIONS" ]]; then
                if [[ -n "$BUILD_ENV" ]]; then
                    env $BUILD_ENV build_with_options go "install $GO_INSTALL_OPTIONS ."
                else
                    build_with_options go "install $GO_INSTALL_OPTIONS ."
                fi
            else
                if [[ -n "$BUILD_ENV" ]]; then
                    env $BUILD_ENV execute_command_safely go install .
                else
                    execute_command_safely go install .
                fi
            fi
            
            # Go install puts binaries in $GOPATH/bin or $HOME/go/bin
            GOPATH_BIN="$HOME/go/bin"
            if [[ -n "$GOPATH" ]]; then
                GOPATH_BIN="$GOPATH/bin"
            fi
            
            # Copy from GOPATH to system location
            if [[ -f "$GOPATH_BIN/fzf" ]]; then
                sudo cp "$GOPATH_BIN/fzf" /usr/local/bin/fzf || error "Failed to install fzf"
                sudo chmod +x /usr/local/bin/fzf
            else
                error "Go install completed but binary not found in $GOPATH_BIN"
            fi
        else
            # Copy built binary directly
            sudo cp "fzf" /usr/local/bin/fzf || error "Failed to install fzf"
            sudo chmod +x /usr/local/bin/fzf
        fi
        
        # Cache the new build
        cache_build "fzf" "$BUILD_TYPE" "/usr/local/bin/fzf"
    fi
else
    # Install using go install or copy binary
    if [[ -f "go.mod" ]]; then
        if [[ -n "$GO_INSTALL_OPTIONS" ]]; then
            if [[ -n "$BUILD_ENV" ]]; then
                env $BUILD_ENV build_with_options go "install $GO_INSTALL_OPTIONS ."
            else
                build_with_options go "install $GO_INSTALL_OPTIONS ."
            fi
        else
            if [[ -n "$BUILD_ENV" ]]; then
                env $BUILD_ENV execute_command_safely go install .
            else
                execute_command_safely go install .
            fi
        fi
        
        # Go install puts binaries in $GOPATH/bin or $HOME/go/bin
        GOPATH_BIN="$HOME/go/bin"
        if [[ -n "$GOPATH" ]]; then
            GOPATH_BIN="$GOPATH/bin"
        fi
        
        # Copy from GOPATH to system location
        if [[ -f "$GOPATH_BIN/fzf" ]]; then
            sudo cp "$GOPATH_BIN/fzf" /usr/local/bin/fzf || error "Failed to install fzf"
            sudo chmod +x /usr/local/bin/fzf
        else
            error "Go install completed but binary not found in $GOPATH_BIN"
        fi
    else
        # Copy built binary directly
        sudo cp "fzf" /usr/local/bin/fzf || error "Failed to install fzf"
        sudo chmod +x /usr/local/bin/fzf
    fi
    
    # Cache the new build
    cache_build "fzf" "$BUILD_TYPE" "/usr/local/bin/fzf"
fi

# Setup shell integration if enabled and supported
if [[ "$ENABLE_SHELL" == true ]] && [[ "fzf" == "fzf" ]]; then
    log "Setting up shell integration for fzf..."
    # Add fzf key bindings and completion
    if [[ -f ~/.bashrc ]]; then
        if ! grep -q "fzf" ~/.bashrc; then
            echo "" >> ~/.bashrc
            echo "# fzf key bindings and fuzzy completion" >> ~/.bashrc
            echo "source <(fzf --bash)" >> ~/.bashrc
            success "fzf shell integration added to ~/.bashrc"
        else
            log "fzf shell integration already configured"
        fi
    fi
fi


# Verify installation
log "Verifying installation..."
# Force PATH update for verification
export PATH="/usr/local/bin:$PATH"
# Clear bash command hash table to ensure new binaries are used
hash -r
if command -v fzf &> /dev/null; then
    success "fzf installation verified!"
    echo
    log "fzf version information:"
    fzf fzf --version
    echo
    log "Build type: $BUILD_TYPE"
    case $BUILD_TYPE in
        debug|minimal)
            log "Features: Debug/minimal build for faster compilation"
            ;;
        release|standard)
            log "Features: Optimized release build with standard features"
            ;;
        static)
            log "Features: Self-contained static binary"
            ;;
        optimized|maximum)
            log "Features: Fully optimized build for maximum performance"
            ;;
    esac
    echo
    success "fzf installation completed successfully!"
    log "You can now use the 'fzf' command"
    echo
    log "Usage examples:"
    log "  fzf                           # Interactive file finder"
    log "  find . -type f | fzf          # Pipe files to fzf"
    log "  git log --oneline | fzf       # Fuzzy find git commits"
    log "  history | fzf                 # Fuzzy find command history"

    echo
    log "Installation paths:"
    log "  fzf: $(which fzf)"
    echo
    log "Script completed in directory: $(pwd)"
else
    error "fzf installation verification failed - check installation path and permissions"
fi